写于2025/7/16，此时这个项目已经接近完成，还有一些微小的地方需要改动。接下来就是最后一步—把程序烧录进FPGA。
对于我的工作，有一些经验应该记录下来。
1.关于系统的调试
在这次开发中，一个大的通用中央处理器被分成Memory，regfile，control-logic等等内容来处理，这其实就是module test的基本思想。通过前期top-down的设计指导，程序的重心被移到了微指令部分，而其他部分的重点只在于连线。
这给我们以启示：对于大型项目，使用top-down设计，先搭好框架，再继续工作。
2.关于硬件描述语言的设计
在这次开发中，刚开始我想采取自己的设计思路—也就是把所有mux，处理逻辑和内存都在一起编写，后来看到matthexking的结构设计才恍然大悟。
在硬件描述语言中，有一个基本结构： topmodule =control module + memory module。
这样调试第一是对外界调用这个结构很友好—所有的数据传输都已经在内部完成了，第二是逻辑比较清晰—内存模块负责接收地址和enable，write-read-en，输入数据，然后输出内存内容就好。
而控制模块只需接受input，访问内存，读或写，然后把结果发送出去就行了。


3.
Vivado 综合工具看到 posedge btn 后，可能会认为 btn 是一个时钟信号（因为 posedge 通常用于时钟）。

FPGA 的最佳实践是：避免用异步信号（如按键）直接作为 always @(posedge) 的触发条件，否则可能导致时序问题

4.timing loop
组合环无疑是最令人头疼的问题，在本次的项目中，本来我还打算超额完成bitstream的generation，但是vivado报的十几个timing loop让人没法接着往下做了。因为理论上整个框架都要大改。

5.vivado仿真过程中不报错且突然中断问题。
在Regfile的程序中，我写了一段比较经典的combinational loop的代码，一个MUX的输入在兜兜转转经过五条线之后又直接与输出相连，于是在运行仿真的时候，仿真器就停在那个点不动，current time一直保持同一个值，console不报错，本应呈现未知态的值也保持原样，导致我们根本没有办法去debug，所幸程序在中断时会把断点以一个绿色光标形式留在程序中，我们因此可以根据这个来挨个排除错误单元并修改。